schema {
  query: Query
  mutation: Mutation
}

directive @constraint(contains: String, endsWith: String, exclusiveMax: Float, exclusiveMin: Float, format: String, max: Float, maxItems: Int, maxLength: Int, min: Float, minItems: Int, minLength: Int, multipleOf: Float, notContains: String, pattern: String, startsWith: String, uniqueTypeName: String) on ARGUMENT_DEFINITION | FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @hidden on FIELD_DEFINITION | OBJECT

directive @private on FIELD_DEFINITION | OBJECT

directive @requireAuth(scopes: [Scope!]) on FIELD_DEFINITION | OBJECT

input AddCommentInput {
  contentMarkdown: String!
  postId: ID!
}

type AddCommentPayload {
  comment: Comment
}

input AddPostToSeriesInput {
  postId: ObjectId!
  seriesId: ObjectId!
}

type AddPostToSeriesPayload {
  series: Series
}

input AddReplyInput {
  commentId: ID!
  contentMarkdown: String!
}

type AddReplyPayload {
  reply: Reply
}

type AudioBlogFeature implements Feature {
  isEnabled: Boolean!
  voiceType: AudioBlogVoiceType!
}

enum AudioBlogVoiceType {
  FEMALE
  MALE
}

type AudioUrls {
  female: String
  male: String
}

enum BackupStatus {
  failed
  success
}

type Badge implements Node {
  dateAssigned: DateTime
  description: String
  id: ID!
  image: String!
  infoURL: String
  name: String!
  suppressed: Boolean
}

type BetaFeature implements Node {
  description: String
  enabled: Boolean!
  id: ID!
  key: String!
  title: String
  url: String
}

input CancelScheduledDraftInput {
  draftId: ID!
}

type CancelScheduledDraftPayload {
  scheduledPost: ScheduledPost!
}

type Comment implements Node {
  author: User!
  content: Content!
  dateAdded: DateTime!
  id: ID!
  reactionCount: Int!
  replies(after: String, first: Int!): CommentReplyConnection!
  stamp: String
  reactionCount: Int!
}

type CommentReplyConnection implements Connection {
  edges: [CommentReplyEdge!]!
  pageInfo: PageInfo!
  totalDocuments: Int!
}

type CommentReplyEdge implements Edge {
  cursor: String!
  node: Reply!
}

type CommenterUserConnection implements Connection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

interface Connection {
  edges: [Edge!]!
  pageInfo: PageInfo!
}

type Content {
  html: String!
  markdown: String!
  text: String!
}

enum CountryCodeAlpha2 {
  AD AE AF AG AI AL AM AO AQ AR AS AT AU AW AX AZ BA BB BD BE BF BG BH BI BJ BL BM BN BO BQ BR BS BT BV BW BY BZ CA CC CD CF CG CH CI CK CL CM CN CO CR CU CV CW CX CY CZ DE DJ DK DM DO DZ EC EE EG EH ER ES ET FI FJ FK FM FO FR GA GB GD GE GF GG GH GI GL GM GN GP GQ GR GS GT GU GW GY HK HM HN HR HT HU ID IE IL IM IN IO IQ IR IS IT JE JM JO JP KE KG KH KI KM KN KP KR KW KY KZ LA LB LC LI LK LR LS LT LU LV LY MA MC MD ME MF MG MH MK ML MM MN MO MP MQ MR MS MT MU MV MW MX MY MZ NA NC NE NF NG NI NL NO NP NR NU NZ OM PA PE PF PG PH PK PL PM PN PR PS PT PW PY QA RE RO RS RU RW SA SB SC SD SE SG SH SI SJ SK SL SM SN SO SR SS ST SV SX SY SZ TC TD TF TG TH TJ TK TL TM TN TO TR TT TV TW TZ UA UG UM US UY UZ VA VC VE VG VI VN VU WF WS YE YT ZA ZM ZW ZZ
}

input CoverImageOptionsInput {
  coverImageAttribution: String
  coverImagePhotographer: String
  coverImageURL: String
  isCoverAttributionHidden: Boolean
  stickCoverToBottom: Boolean
}

input CreateDraftInput {
  coAuthors: [ObjectId!]
  contentMarkdown: String
  coverImageOptions: CoverImageOptionsInput
  disableComments: Boolean
  metaTags: MetaTagsInput
  originalArticleURL: String
  publicationId: ID!
  publishAs: ObjectId
  publishedAt: DateTime
  seriesId: ObjectId
  settings: CreateDraftSettingsInput
  slug: String
  subtitle: String
  tags: [CreateDraftTagInput!]
  title: String
}

type CreateDraftPayload {
  draft: Draft
}

input CreateDraftSettingsInput {
  activateNewsletter: Boolean
  delist: Boolean
  enableTableOfContent: Boolean
  slugOverridden: Boolean
}

input CreateDraftTagInput {
  id: ObjectId
  name: String
  slug: String
}

input CreateSeriesInput {
  coverImage: String
  descriptionMarkdown: String
  name: String!
  publicationId: ID!
  slug: String!
  sortOrder: SortOrder
}


type CreateSeriesPayload {
  series: Series!
}

input CreateWebhookInput {
  events: [WebhookEvent!]!
  publicationId: ID!
  secret: String!
  url: String!
}

type CreateWebhookPayload {
  webhook: Webhook
}

type CustomCSS {
  home: String
  homeMinified: String
  post: String
  postMinified: String
  static: String
  staticMinified: String
}

type CustomCSSFeature implements Feature {
  draft: CustomCSS
  isEnabled: Boolean!
  published: CustomCSS
}

enum CustomDomainStatus {
  INVALID
  VALID
  VERIFYING
}

type DarkModePreferences {
  enabled: Boolean
  logo: String
}

scalar DateTime

input DeleteRoleBasedInviteInput {
  inviteId: ID!
  publicationId: ID!
}

type DeleteRoleBasedInvitePayload {
  invite: RoleBasedInvite!
}

type DeleteWebhookPayload {
  webhook: Webhook
}

enum DeviceType {
  DESKTOP
  LAPTOP
  MOBILE
  TABLET
}

type DomainInfo {
  domain: DomainStatus
  hashnodeSubdomain: String
  wwwPrefixedDomain: DomainStatus
}

type DomainStatus {
  host: String!
  ready: Boolean!
  status: CustomDomainStatus!
  verifiedAt: DateTime
}

type Draft implements Node {
  author: User!
  canonicalUrl: String
  coAuthors: [User!]
  content: Content
  coverImage: DraftCoverImage
  dateUpdated: DateTime! @deprecated(reason: "Use updatedAt instead. Will be removed on 26/12/2023.")
  features: DraftFeatures!
  id: ID!
  lastBackup: DraftBackup
  lastFailedBackupAt: DateTime
  lastSuccessfulBackupAt: DateTime
  ogMetaData: OpenGraphMetaData
  readTimeInMinutes: Int!
  scheduledDate: DateTime
  seo: SEO
  series: Series
  settings: DraftSettings!
  slug: String!
  subtitle: String
  tagsV2: [DraftTag!]!
  title: String
  updatedAt: DateTime!
}

type DraftBackup {
  at: DateTime
  status: BackupStatus
}

type DraftBaseTag {
  name: String!
  slug: String!
}

type DraftConnection implements Connection {
  edges: [DraftEdge!]!
  pageInfo: PageInfo!
  totalDocuments: Int!
}

type DraftCoverImage {
  attribution: String
  isAttributionHidden: Boolean!
  photographer: String
  url: String!
}

type DraftEdge implements Edge {
  cursor: String!
  node: Draft!
}

type DraftFeatures {
  tableOfContents: TableOfContentsFeature!
}

type DraftSettings {
  disableComments: Boolean!
  isDelisted: Boolean!
  stickCoverToBottom: Boolean!
}

union DraftTag = DraftBaseTag | Tag

type EmailCurrentImport {
  attemptedToImport: Int
  filename: String
  importStartedAt: DateTime!
  status: EmailImportStatus!
  successfullyImported: Int
}

type EmailImport {
  currentImport: EmailCurrentImport
}

enum EmailImportStatus {
  FAILED
  FINISHED
  INITIALIZED
  IN_PROGRESS
  IN_REVIEW
  REJECTED
  SUCCESS
}

interface Feature {
  isEnabled: Boolean!
}

input FeedFilter {
  maxReadTime: Int
  minReadTime: Int
  tags: [ObjectId!]
  type: FeedType
}

type FeedPostConnection implements Connection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
}

enum FeedType {
  BOOKMARKS
  FEATURED
  FOLLOWING
  PERSONALIZED
  READING_HISTORY
  RECENT
  RELEVANT
}

type GroupedByBrowserViews implements Node & Views {
  browser: String!
  id: ID!
  total: Int!
}

type GroupedByBrowserVisitors implements Node & Visitors {
  browser: String!
  id: ID!
  total: Int!
}

type GroupedByCountryViews implements Node & Views {
  country: CountryCodeAlpha2!
  id: ID!
  total: Int!
}

type GroupedByCountryVisitors implements Node & Visitors {
  country: CountryCodeAlpha2!
  id: ID!
  total: Int!
}

type GroupedByDeviceTypeViews implements Node & Views {
  deviceType: DeviceType!
  id: ID!
  total: Int!
}

type GroupedByDeviceTypeVisitors implements Node & Visitors {
  deviceType: DeviceType!
  id: ID!
  total: Int!
}

type GroupedByOperatingSystemViews implements Node & Views {
  id: ID!
  operatingSystem: String!
  total: Int!
}

type GroupedByOperatingSystemVisitors implements Node & Visitors {
  id: ID!
  operatingSystem: String!
  total: Int!
}

type GroupedByPageViews implements Node & Views {
  id: ID!
  page: StaticPage!
  total: Int!
}

type GroupedByPageVisitors implements Node & Visitors {
  id: ID!
  page: StaticPage!
  total: Int!
}

type GroupedByPathViews implements Node & Views {
  id: ID!
  path: String!
  total: Int!
}

type GroupedByPathVisitors implements Node & Visitors {
  id: ID!
  path: String!
  total: Int!
}

type GroupedByPostViews implements Node & Views {
  id: ID!
  post: Post!
  total: Int!
}

type GroupedByPostVisitors implements Node & Visitors {
  id: ID!
  post: Post!
  total: Int!
}

type GroupedByReferrerHostViews implements Node & Views {
  id: ID!
  referrerHost: String!
  total: Int!
}

type GroupedByReferrerHostVisitors implements Node & Visitors {
  id: ID!
  referrerHost: String!
  total: Int!
}

type GroupedByTimeViews implements Node & Views {
  from: DateTime!
  id: ID!
  to: DateTime!
  total: Int!
}

type GroupedByTimeVisitors implements Node & Visitors {
  from: DateTime!
  id: ID!
  to: DateTime!
  total: Int!
}

enum HttpRedirectionType {
  PERMANENT
  TEMPORARY
}

interface ITag {
  followersCount: Int!
  id: ID!
  info: Content
  logo: String
  name: String!
  postsCount: Int!
  slug: String!
  tagline: String
}

interface IUser {
  ambassador: Boolean!
  availableFor: String
  badges: [Badge!]!
  bio: Content
  dateJoined: DateTime
  deactivated: Boolean!
  followers(page: Int!, pageSize: Int!): UserConnection!
  followersCount: Int!
  followingsCount: Int!
  follows(page: Int!, pageSize: Int!): UserConnection!
  id: ID!
  location: String
  name: String!
  posts(filter: UserPostConnectionFilter, page: Int!, pageSize: Int!, sortBy: UserPostsSort = DATE_PUBLISHED_DESC): UserPostConnection!
  profilePicture: String
  publications(after: String, filter: UserPublicationsConnectionFilter, first: Int!): UserPublicationsConnection!
  socialMediaLinks: SocialMediaLinks
  tagline: String
  tagsFollowing: [Tag!]!
  username: String!
}

input LikeCommentInput {
  commentId: ID!
  likesCount: Int = 1
}

type LikeCommentPayload {
  comment: Comment
}

input LikePostInput {
  likesCount: Int = 1
  postId: ID!
}

type LikePostPayload {
  post: Post
}

input LikeReplyInput {
  commentId: ID!
  likesCount: Int = 1
  replyId: ID!
}

type LikeReplyPayload {
  reply: Reply
}

input MetaTagsInput {
  description: String
  image: String
  title: String
}

type Mutation {
  addComment(input: AddCommentInput!): AddCommentPayload!
  addPostToSeries(input: AddPostToSeriesInput!): AddPostToSeriesPayload!
  addReply(input: AddReplyInput!): AddReplyPayload!
  cancelScheduledDraft(input: CancelScheduledDraftInput!): CancelScheduledDraftPayload!
  createDraft(input: CreateDraftInput!): CreateDraftPayload!
  createSeries(input: CreateSeriesInput!): CreateSeriesPayload!
  createWebhook(input: CreateWebhookInput!): CreateWebhookPayload!
  deleteRoleBasedInvite(input: DeleteRoleBasedInviteInput!): DeleteRoleBasedInvitePayload!
  deleteWebhook(id: ID!): DeleteWebhookPayload!
  likeComment(input: LikeCommentInput!): LikeCommentPayload!
  likePost(input: LikePostInput!): LikePostPayload!
  likeReply(input: LikeReplyInput!): LikeReplyPayload!
  publishDraft(input: PublishDraftInput!): PublishDraftPayload!
  publishPost(input: PublishPostInput!): PublishPostPayload!
  recommendPublications(input: RecommendPublicationsInput!): RecommendPublicationsPayload!
  removeComment(input: RemoveCommentInput!): RemoveCommentPayload!
  removePost(input: RemovePostInput!): RemovePostPayload!
  removeRecommendation(input: RemoveRecommendationInput!): RemoveRecommendationPayload!
  removeReply(input: RemoveReplyInput!): RemoveReplyPayload!
  removeSeries(input: RemoveSeriesInput!): RemoveSeriesPayload!
  rescheduleDraft(input: RescheduleDraftInput!): RescheduleDraftPayload!
  resendWebhookRequest(input: ResendWebhookRequestInput!): ResendWebhookRequestPayload!
  restorePost(input: RestorePostInput!): RestorePostPayload!
  scheduleDraft(input: ScheduleDraftInput!): ScheduleDraftPayload!
  subscribeToNewsletter(input: SubscribeToNewsletterInput!): SubscribeToNewsletterPayload!
  toggleFollowUser(id: ID, username: String): ToggleFollowUserPayload!
  triggerWebhookTest(input: TriggerWebhookTestInput!): TriggerWebhookTestPayload!
  unsubscribeFromNewsletter(input: UnsubscribeFromNewsletterInput!): UnsubscribeFromNewsletterPayload!
  updateComment(input: UpdateCommentInput!): UpdateCommentPayload!
  updatePost(input: UpdatePostInput!): UpdatePostPayload!
  updateReply(input: UpdateReplyInput!): UpdateReplyPayload!
  updateSeries(input: UpdateSeriesInput!): UpdateSeriesPayload!
  updateWebhook(input: UpdateWebhookInput!): UpdateWebhookPayload!
}

type MyUser implements IUser & Node {
  ambassador: Boolean! @deprecated(reason: "Ambassadors program no longer active. Will be removed after 02/01/2024")
  availableFor: String
  badges: [Badge!]!
  betaFeatures: [BetaFeature!]!
  bio: Content
  dateJoined: DateTime
  deactivated: Boolean!
  followers(page: Int!, pageSize: Int!): UserConnection!
  followersCount: Int!
  followingsCount: Int!
  follows(page: Int!, pageSize: Int!): UserConnection!
  id: ID!
  location: String
  name: String!
  posts(filter: UserPostConnectionFilter, page: Int!, pageSize: Int!, sortBy: UserPostsSort = DATE_PUBLISHED_DESC): UserPostConnection!
  profilePicture: String
  provider: String
  publications(after: String, filter: UserPublicationsConnectionFilter, first: Int!): UserPublicationsConnection!
  socialMediaLinks: SocialMediaLinks
  tagline: String
  tagsFollowing: [Tag!]!
  username: String!
}

type NewsletterFeature implements Feature {
  frequency: NewsletterFrequency
  isEnabled: Boolean!
}

enum NewsletterFrequency {
  asap
  weekly
}

type NewsletterRecord implements Node {
  clickCount: Int!
  id: ID!
  openCount: Int!
  post: Post!
  sentAt: DateTime!
  sentCount: Int!
}

enum NewsletterSubscribeStatus {
  CONFIRMED
  PENDING
}

type NewsletterSubscriber implements Node {
  createdAt: DateTime! @deprecated(reason: "Use `subscribedAt` instead. Will be removed after 12/4/2024")
  email: String!
  id: ID!
  status: NewsletterSubscribeStatus!
  subscribedAt: DateTime!
}

enum NewsletterUnsubscribeStatus {
  UNSUBSCRIBED
}

interface Node {
  id: ID!
}

scalar ObjectId

type OffsetPageInfo {
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  nextPage: Int
  previousPage: Int
}

type OpenGraphMetaData {
  image: String
}

interface PageConnection {
  nodes: [Node!]!
  pageInfo: OffsetPageInfo!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean
}

type PagesPreferences {
  badges: Boolean
  members: Boolean
  newsletter: Boolean
}

type PendingInvite implements Node {
  email: String
  id: ID!
  role: UserPublicationRole!
  user: User
}

type PopularTag implements ITag & Node {
  followersCount: Int!
  id: ID!
  info: Content
  logo: String
  name: String!
  postsCount: Int!
  postsCountInPeriod: Int!
  slug: String!
  tagline: String
}

type PopularTagEdge implements Edge {
  cursor: String!
  node: PopularTag!
}

type Post implements Node {
  audioUrls: AudioUrls @deprecated(reason: "Audio Blogs are not supported anymore. This field will be removed 18/04/23")
  author: User!
  bookmarked: Boolean!
  brief: String!
  canonicalUrl: String
  coAuthors: [User!]
  commenters(after: String, first: Int!, sortBy: PostCommenterSortBy): PostCommenterConnection!
  comments(after: String, first: Int!, sortBy: PostCommentSortBy): PostCommentConnection!
  content: Content!
  contributors: [User!]! @deprecated(reason: "Will be removed on 10th Oct 2023. Use `commenters` instead.")
  coverImage: PostCoverImage
  cuid: String
  featured: Boolean!
  featuredAt: DateTime
  features: PostFeatures!
  hasLatexInPost: Boolean!
  id: ID!
  isAutoPublishedFromRSS: Boolean!
  isFollowed: Boolean
  likedBy(after: String, filter: PostLikerFilter, first: Int!): PostLikerConnection!
  ogMetaData: OpenGraphMetaData
  preferences: PostPreferences!
  publication: Publication
  publishedAt: DateTime!
  reactionCount: Int!
  readTimeInMinutes: Int!
  replyCount: Int!
  responseCount: Int!
  seo: SEO
  series: Series
  slug: String!
  sourcedFromGithub: Boolean!
  subtitle: String
  tags: [Tag!]
  title: String!
  updatedAt: DateTime
  url: String!
  views: Int!
}

enum PostAuthorType {
  AUTHOR
  CO_AUTHOR
}

type PostBadge implements Node {
  id: ID!
  type: PostBadgeType!
}

enum PostBadgeType {
  FEATURED_DAILY_DOT_DEV
  FEATURED_HASHNODE
}

type PostBadgesFeature implements Feature {
  isEnabled: Boolean!
  items: [PostBadge!]!
}

type PostCommentConnection implements Connection {
  edges: [PostCommentEdge!]!
  pageInfo: PageInfo!
  totalDocuments: Int!
}

type PostCommentEdge implements Edge {
  cursor: String!
  node: Comment!
}



enum PostCommentSortBy {
  RECENT
  TOP
}

type PostCommenterConnection implements Connection {
  edges: [PostCommenterEdge!]!
  pageInfo: PageInfo!
  totalDocuments: Int!
}

type PostCommenterEdge implements Edge {
  cursor: String!
  node: User!
}

enum PostCommenterSortBy {
  POPULAR
  RECENT
}

type PostCoverImage {
  attribution: String
  isAttributionHidden: Boolean!
  isPortrait: Boolean!
  photographer: String
  url: String!
}

type PostEdge implements Edge {
  cursor: String!
  node: Post!
}

type PostFeatures {
  badges: PostBadgesFeature!
  tableOfContents: TableOfContentsFeature!
}

type PostLikerConnection implements Connection {
  edges: [PostLikerEdge!]!
  pageInfo: PageInfo!
  totalDocuments: Int!
}

type PostLikerEdge implements Edge {
  cursor: String!
  node: User!
  reactionCount: Int!
}

input PostLikerFilter {
  userIds: [ID!]
}

type PostPreferences {
  disableComments: Boolean!
  isDelisted: Boolean!
  pinnedToBlog: Boolean!
  stickCoverToBottom: Boolean!
}

type Preferences {
  darkMode: DarkModePreferences
  disableFooterBranding: Boolean
  enabledPages: PagesPreferences
  isSubscriptionModalDisabled: Boolean
  layout: PublicationLayout
  logo: String
  navbarItems: [PublicationNavbarItem!]!
}

type Publication implements Node {
  about: Content
  allowContributorEdits: Boolean!
  author: User!
  canonicalURL: String!
  descriptionSEO: String
  displayTitle: String
  domainInfo: DomainInfo!
  drafts(after: String, filter: PublicationDraftConnectionFilter, first: Int!): DraftConnection!
  emailImport: EmailImport
  favicon: String
  features: PublicationFeatures!
  followersCount: Int
  hasBadges: Boolean!
  headerColor: String
  id: ID!
  imprintV2: Content
  integrations: PublicationIntegrations
  isGitHubBackupEnabled: Boolean!
  isHeadless: Boolean!
  isTeam: Boolean!
  links: PublicationLinks
  metaTags: String
  ogMetaData: OpenGraphMetaData!
  pinnedPost: Post
  post(slug: String!): Post
  posts(after: String, filter: PublicationPostConnectionFilter, first: Int!): PublicationPostConnection!
  postsViaPage(page: Int!, pageSize: Int!): PublicationPostPageConnection!
  preferences: Preferences!
  recommendedPublications: [UserRecommendedPublicationEdge!]!
  recommendingPublications(page: Int!, pageSize: Int!): PublicationUserRecommendingPublicationConnection!
  redirectionRules: [RedirectionRule!]!
  scheduledDrafts(after: String, filter: PublicationDraftConnectionFilter, first: Int!): DraftConnection!
  series(slug: String!): Series
  seriesList(after: String, first: Int!): SeriesConnection!
  sponsorship: PublicationSponsorship
  staticPage(slug: String!): StaticPage
  staticPages(after: String, first: Int!): StaticPageConnection!
  submittedDrafts(after: String, filter: PublicationDraftConnectionFilter, first: Int!): DraftConnection!
  title: String!
  totalRecommendedPublications: Int!
  url: String!
  urlPattern: UrlPattern!
}

input PublicationDraftConnectionFilter {
  search: String
}

type PublicationFeatures {
  audioBlog: AudioBlogFeature! @deprecated(reason: "Audio Blogs are not supported anymore. This field will be removed 18/04/23")
  customCSS: CustomCSSFeature!
  newsletter: NewsletterFeature!
  readTime: ReadTimeFeature!
  textSelectionSharer: TextSelectionSharerFeature!
  viewCount: ViewCountFeature!
}

type PublicationIntegrations {
  fathomCustomDomain: String
  fathomCustomDomainEnabled: Boolean
  fathomSiteID: String
  fbPixelID: String
  gTagManagerID: String
  gaTrackingID: String
  hotjarSiteID: String
  matomoSiteID: String
  matomoURL: String
  plausibleAnalyticsEnabled: Boolean
  umamiShareId: String
  umamiWebsiteUUID: String
  wmPaymentPointer: String
}

enum PublicationLayout {
  grid
  magazine
  stacked
}

type PublicationLinks {
  dailydev: String
  github: String
  hashnode: String
  instagram: String
  linkedin: String
  mastodon: String
  twitter: String
  website: String
  youtube: String
}

type PublicationMember implements Node {
  id: ID!
  privacyState: PublicationMemberPrivacyState
  role: UserPublicationRole!
  user: User
}

enum PublicationMemberPrivacyState {
  PRIVATE
  PUBLIC
}

type PublicationNavbarItem {
  id: ID!
  label: String
  page: StaticPage
  priority: Int @deprecated(reason: "Navbar items are already returned in the correct order. Priority value is not needed and might be 0 in most cases.")
  series: Series
  type: PublicationNavigationType!
  url: String
}

enum PublicationNavigationType {
  link
  page
  series
}

type PublicationPostConnection implements Connection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
  totalDocuments: Int!
}

input PublicationPostConnectionFilter {
  deletedOnly: Boolean
  excludePinnedPost: Boolean
  tagSlugs: [String!]
  tags: [ObjectId!]
}

type PublicationPostPageConnection implements PageConnection {
  nodes: [Post!]!
  pageInfo: OffsetPageInfo!
  totalDocuments: Int!
}

type PublicationSponsorship {
  content: Content
  stripe: StripeConfiguration
}

type PublicationUserRecommendingPublicationConnection implements PageConnection {
  edges: [UserRecommendingPublicationEdge!]!
  nodes: [Publication!]!
  pageInfo: OffsetPageInfo!
  totalDocuments: Int!
}

type PublicationViewEdge implements Edge {
  cursor: String!
  node: Views!
}

type PublicationVisitorsEdge implements Edge {
  cursor: String!
  node: Visitors!
}

input PublishDraftInput {
  draftId: ObjectId!
}

type PublishDraftPayload {
  post: Post
}

input PublishPostInput {
  coAuthors: [ObjectId!]
  contentMarkdown: String!
  coverImageOptions: CoverImageOptionsInput
  disableComments: Boolean
  metaTags: MetaTagsInput
  originalArticleURL: String
  publicationId: ObjectId!
  publishAs: ObjectId
  publishedAt: DateTime
  seriesId: ObjectId
  settings: PublishPostSettingsInput
  slug: String
  subtitle: String
  tags: [PublishPostTagInput!]
  title: String!
}

type PublishPostPayload {
  post: Post
}

input PublishPostSettingsInput {
  delisted: Boolean
  enableTableOfContent: Boolean
  isNewsletterActivated: Boolean
  scheduled: Boolean
  slugOverridden: Boolean
}

input PublishPostTagInput {
  id: ObjectId
  name: String
  slug: String
}

type Query {
  draft(id: ObjectId!): Draft
  feed(after: String, filter: FeedFilter, first: Int!): FeedPostConnection!
  me: MyUser!
  post(id: ID!): Post
  publication(host: String, id: ObjectId): Publication
  scheduledPost(id: ObjectId): ScheduledPost
  searchPostsOfPublication(after: String, filter: SearchPostsOfPublicationFilter!, first: Int!): SearchPostConnection!
  tag(slug: String!): Tag
  topCommenters(after: String, first: Int!): CommenterUserConnection!
  user(username: String!): User
}

type RSSImport implements Node {
  id: ID!
  importAsDrafts: Boolean!
  rssTagName: String
  rssURL: String!
  scrapePosts: Boolean!
}
type ReadTimeFeature implements Feature {
  isEnabled: Boolean!
}

input RecommendPublicationsInput {
  recommendedPublicationIds: [ID!]!
  recommendingPublicationId: ID!
}

type RecommendPublicationsPayload {
  recommendedPublications: [UserRecommendedPublicationEdge!]
}

type RecommendedPublicationEdge implements Edge {
  cursor: String!
  node: Publication!
}

type RedirectionRule implements Node {
  destination: URL!
  id: ID!
  source: String!
  type: HttpRedirectionType!
}

input RemoveCommentInput {
  id: ID!
}

type RemoveCommentPayload {
  comment: Comment
}

input RemovePostInput {
  id: ID!
}

type RemovePostPayload {
  post: Post
}

input RemoveRecommendationInput {
  recommendedPublicationId: ID!
  recommendingPublicationId: ID!
}

type RemoveRecommendationPayload {
  recommendedPublication: Publication!
}

input RemoveReplyInput {
  commentId: ID!
  replyId: ID!
}

type RemoveReplyPayload {
  reply: Reply
}

input RemoveSeriesInput {
  id: ID!
}

type RemoveSeriesPayload {
  series: Series!
}

type Reply implements Node {
  author: User!
  content: Content!
  dateAdded: DateTime!
  id: ID!
  reactionCount: Int!
  stamp: String
  reactionCount: Int!
}

input RescheduleDraftInput {
  draftId: ID!
  publishAt: DateTime!
}

type RescheduleDraftPayload {
  scheduledPost: ScheduledPost!
}

input ResendWebhookRequestInput {
  webhookId: ID!
  webhookMessageId: ID!
}

type ResendWebhookRequestPayload {
  webhookMessage: WebhookMessage
}

input RestorePostInput {
  id: ID!
}

type RestorePostPayload {
  post: Post
}

type RoleBasedInvite implements Node {
  capacity: Int
  expiryDate: DateTime
  id: ID!
  inviteLink: String
  isUnlimitedCapacity: Boolean
  role: UserPublicationRole!
}

type SEO {
  description: String
  title: String
}

input ScheduleDraftInput {
  authorId: ID!
  draftId: ID!
  publishAt: DateTime!
}

type ScheduleDraftPayload {
  scheduledPost: ScheduledPost!
}

type ScheduledPost implements Node {
  author: User!
  draft: Draft
  id: ID!
  publication: Publication!
  scheduledBy: User
  scheduledDate: DateTime!
}

enum Scope {
  acknowledge_email_import
  active_pro_user
  assign_pro_publications
  change_pro_subscription
  create_pro
  docs_editor_or_owner
  docs_owner
  import_subscribers_to_publication
  invited_team_user
  publication_admin
  publication_member
  publish_comment
  publish_draft
  publish_post
  publish_reply
  recommend_publications
  remove_comment
  remove_reply
  restore_post
  signup
  team_hashnode
  update_comment
  update_post
  update_reply
  webhook_admin
  write_draft
  write_post
  write_series
  write_static_page
  write_widget
}

type SearchPostConnection implements Connection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
}

input SearchPostsOfPublicationFilter {
  deletedOnly: Boolean
  publicationId: ObjectId!
  query: String!
}

type SearchUser implements Node {
  id: ID!
  pendingInviteStatus: Boolean
  user: User!
}
type Series implements Node {
  author: User!
  coverImage: String
  createdAt: DateTime!
  cuid: ID
  description: Content
  id: ID!
  name: String!
  posts(after: String, first: Int!): SeriesPostConnection!
  slug: String!
  sortOrder: SortOrder!
}

type SeriesConnection implements Connection {
  edges: [SeriesEdge!]!
  pageInfo: PageInfo!
  totalDocuments: Int!
}

type SeriesEdge implements Edge {
  cursor: String!
  node: Series!
}

type SeriesPostConnection implements Connection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
  totalDocuments: Int!
}

type StaticPage implements Node {
  content: Content!
  hidden: Boolean!
  id: ID!
  ogMetaData: OpenGraphMetaData
  seo: SEO
  slug: String!
  title: String!
}

type StaticPageConnection implements Connection {
  edges: [StaticPageEdge!]!
  pageInfo: PageInfo!
  totalDocuments: Int!
}

type StaticPageEdge implements Edge {
  cursor: String!
  node: StaticPage!
}

type StripeConfiguration {
  accountId: String
  connected: Boolean!
  country: String
}

input SubscribeToNewsletterInput {
  email: String!
  publicationId: ObjectId!
}

type SubscribeToNewsletterPayload {
  status: NewsletterSubscribeStatus
}

type TableOfContentsFeature implements Feature {
  isEnabled: Boolean!
  items: [TableOfContentsItem!]!
}

type TableOfContentsItem implements Node {
  id: ID!
  level: Int!
  parentId: ID
  slug: String!
  title: String!
}

type Tag implements ITag & Node {
  followersCount: Int!
  id: ID!
  info: Content
  logo: String
  name: String!
  posts(after: String, filter: TagPostConnectionFilter!, first: Int!): FeedPostConnection!
  postsCount: Int!
  slug: String!
  tagline: String
}

type TagEdge implements Edge {
  cursor: String!
  node: Tag!
}

input TagPostConnectionFilter {
  sortBy: TagPostsSort
}

enum TagPostsSort {
  popular
  recent
  trending
}

type TextSelectionSharerFeature implements Feature {
  isEnabled: Boolean!
}

type ToggleFollowUserPayload {
  user: User
}

input TriggerWebhookTestInput {
  webhookId: ID!
}

type TriggerWebhookTestPayload {
  webhook: Webhook
}

scalar URL

type UngroupedViews implements Node & Views {
  id: ID!
  total: Int!
}

type UngroupedVisitors implements Node & Visitors {
  id: ID!
  total: Int!
}

input UnsubscribeFromNewsletterInput {
  email: String!
  publicationId: ObjectId!
}

type UnsubscribeFromNewsletterPayload {
  status: NewsletterUnsubscribeStatus
}

input UpdateCommentInput {
  contentMarkdown: String!
  id: ID!
}

type UpdateCommentPayload {
  comment: Comment
}

input UpdatePostInput {
  coAuthors: [ObjectId!]
  contentMarkdown: String
  coverImageOptions: CoverImageOptionsInput
  id: ID!
  metaTags: MetaTagsInput
  originalArticleURL: String
  publicationId: ObjectId
  publishAs: ObjectId
  publishedAt: DateTime
  seriesId: ObjectId
  settings: UpdatePostSettingsInput
  slug: String
  subtitle: String
  tags: [PublishPostTagInput!]
  title: String
}

type UpdatePostPayload {
  post: Post
}

input UpdatePostSettingsInput {
  delisted: Boolean
  disableComments: Boolean
  isTableOfContentEnabled: Boolean
  pinToBlog: Boolean
}

input UpdateReplyInput {
  commentId: ID!
  contentMarkdown: String!
  replyId: ID!
}

type UpdateReplyPayload {
  reply: Reply
}

input UpdateSeriesInput {
  coverImage: String
  descriptionMarkdown: String
  id: ID!
  name: String
  slug: String
  sortOrder: SortOrder
}

type UpdateSeriesPayload {
  series: Series!
}

input UpdateWebhookInput {
  events: [WebhookEvent!]
  id: ID!
  secret: String
  url: String
}

type UpdateWebhookPayload {
  webhook: Webhook
}

enum UrlPattern {
  DEFAULT
  SIMPLE
}

type User implements IUser & Node {
  ambassador: Boolean! @deprecated(reason: "Ambassadors program no longer active. Will be removed after 02/01/2024")
  availableFor: String
  badges: [Badge!]!
  bio: Content
  bioV2: Content @deprecated(reason: "Will be removed on 26/10/2023. Use bio instead of bioV2")
  dateJoined: DateTime
  deactivated: Boolean!
  followers(page: Int!, pageSize: Int!): UserConnection!
  followersCount: Int!
  following: Boolean!
  followingsCount: Int!
  follows(page: Int!, pageSize: Int!): UserConnection!
  followsBack: Boolean!
  id: ID!
  isPro: Boolean!
  location: String
  name: String!
  posts(filter: UserPostConnectionFilter, page: Int!, pageSize: Int!, sortBy: UserPostsSort = DATE_PUBLISHED_DESC): UserPostConnection!
  profilePicture: String
  publications(after: String, filter: UserPublicationsConnectionFilter, first: Int!): UserPublicationsConnection!
  socialMediaLinks: SocialMediaLinks
  tagline: String
  tagsFollowing: [Tag!]!
  username: String!
}

type UserConnection implements PageConnection {
  nodes: [User!]!
  pageInfo: OffsetPageInfo!
  totalDocuments: Int!
}

type UserEdge implements Edge {
  cursor: String!
  node: User!
}

type UserPostConnection implements PageConnection {
  edges: [UserPostEdge!]!
  nodes: [Post!]!
  pageInfo: OffsetPageInfo!
  totalDocuments: Int!
}

input UserPostConnectionFilter {
  authorType: UserPostsAuthorTypeFilter
  publications: [ID!]
  tagSlugs: [String!]
  tags: [ID!]
}

type UserPostEdge {
  authorType: PostAuthorType!
  node: Post!
}

enum UserPostsAuthorTypeFilter {
  AUTHOR_ONLY
  CO_AUTHOR_ONLY
}

enum UserPostsSort {
  DATE_PUBLISHED_ASC
  DATE_PUBLISHED_DESC
}

enum UserPublicationRole {
  CONTRIBUTOR
  EDITOR
  OWNER
}
type UserPublicationsConnection implements Connection {
  edges: [UserPublicationsEdge!]!
  pageInfo: PageInfo!
  totalDocuments: Int!
}

input UserPublicationsConnectionFilter {
  isPro: Boolean
  roles: [UserPublicationRole!]
}

type UserPublicationsEdge implements Edge {
  cursor: String!
  node: Publication!
  role: UserPublicationRole!
}

type UserRecommendedPublicationEdge {
  node: Publication!
  totalFollowersGained: Int!
}

type UserRecommendingPublicationEdge {
  node: Publication!
  totalFollowersGained: Int!
}

type ViewCountFeature implements Feature {
  isEnabled: Boolean!
}

interface Views implements Node {
  id: ID!
  total: Int!
}

interface Visitors implements Node {
  id: ID!
  total: Int!
}

type Webhook implements Node {
  createdAt: DateTime!
  events: [WebhookEvent!]!
  id: ID!
  messages(after: String, first: Int!): WebhookMessageConnection!
  publication: Publication!
  secret: String!
  updatedAt: DateTime
  url: String!
}

enum WebhookEvent {
  POST_DELETED
  POST_PUBLISHED
  POST_UPDATED
  STATIC_PAGE_DELETED
  STATIC_PAGE_EDITED
  STATIC_PAGE_PUBLISHED
}

type WebhookMessage implements Node {
  createdAt: DateTime!
  event: WebhookEvent!
  id: ID!
  isError: Boolean!
  isResent: Boolean!
  isTest: Boolean!
  request: WebhookMessageRequest!
  response: WebhookMessageResponse
  url: String!
}

type WebhookMessageConnection implements Connection {
  edges: [WebhookMessageEdge!]!
  pageInfo: PageInfo!
}

type WebhookMessageEdge implements Edge {
  cursor: String!
  node: WebhookMessage!
}

type WebhookMessageRequest {
  body: String!
  error: WebhookMessageRequestError
  headers: String!
  uuid: String!
}

type WebhookMessageRequestError {
  code: String!
  message: String!
}

type WebhookMessageResponse {
  body: String
  headers: String
  httpStatus: Int!
  timeToFirstByteMilliseconds: Int
}

type Widget implements Node {
  content: String!
  createdAt: DateTime!
  id: ID!
  pinSettings: WidgetPinSettings
  widgetId: String!
}

enum WidgetPinLocation {
  BOTTOM
  TOP
}

type WidgetPinSettings {
  isPinned: Boolean!
  location: WidgetPinLocation!
}
